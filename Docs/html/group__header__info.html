<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Finding Pooky: Header Information</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="gar.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Finding Pooky
   </div>
   <div id="projectbrief">Platformer game where the Garfield</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#define-members">Macros</a>  </div>
  <div class="headertitle">
<div class="title">Header Information</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_opus_head.html">OpusHead</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_opus_tags.html">OpusTags</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_opus_picture_tag.html">OpusPictureTag</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:gad6f0329582430a828244045ac85a5417"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__header__info.html#gad6f0329582430a828244045ac85a5417">OPUS_CHANNEL_COUNT_MAX</a>&#160;&#160;&#160;(255)</td></tr>
<tr class="separator:gad6f0329582430a828244045ac85a5417"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Picture tag image formats</h2></td></tr>
<tr class="memitem:gade2f09dce6330529fc3c96d1740df653"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__header__info.html#gade2f09dce6330529fc3c96d1740df653">OP_PIC_FORMAT_UNKNOWN</a>&#160;&#160;&#160;(-1)</td></tr>
<tr class="separator:gade2f09dce6330529fc3c96d1740df653"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaac4ef30a33caf090b9b1a5ada8f48204"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__header__info.html#gaac4ef30a33caf090b9b1a5ada8f48204">OP_PIC_FORMAT_URL</a>&#160;&#160;&#160;(0)</td></tr>
<tr class="separator:gaac4ef30a33caf090b9b1a5ada8f48204"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf75ae037b78a4a048359261439395450"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__header__info.html#gaf75ae037b78a4a048359261439395450">OP_PIC_FORMAT_JPEG</a>&#160;&#160;&#160;(1)</td></tr>
<tr class="separator:gaf75ae037b78a4a048359261439395450"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga703554b177ae75bd6999bbd30d485d3f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__header__info.html#ga703554b177ae75bd6999bbd30d485d3f">OP_PIC_FORMAT_PNG</a>&#160;&#160;&#160;(2)</td></tr>
<tr class="separator:ga703554b177ae75bd6999bbd30d485d3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa7d5e8cb675cb2da840f258b761e7781"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__header__info.html#gaa7d5e8cb675cb2da840f258b761e7781">OP_PIC_FORMAT_GIF</a>&#160;&#160;&#160;(3)</td></tr>
<tr class="separator:gaa7d5e8cb675cb2da840f258b761e7781"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Functions for manipulating header data</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrp14ef5f819e97c870c128539ed1f334e3"></a>These functions manipulate the <a class="el" href="struct_opus_head.html">OpusHead</a> and <a class="el" href="struct_opus_tags.html">OpusTags</a> structures, which describe the audio parameters and tag-value metadata, respectively. These can be used to query the headers returned by <code>libopusfile</code>, or to parse Opus headers from sources other than an Ogg Opus stream, provided they use the same format. </p>
</td></tr>
<tr class="memitem:gac3259b44ac8dfac93c7adf708de96d78"><td class="memItemLeft" align="right" valign="top">OP_WARN_UNUSED_RESULT int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__header__info.html#gac3259b44ac8dfac93c7adf708de96d78">opus_head_parse</a> (<a class="el" href="struct_opus_head.html">OpusHead</a> *_head, const unsigned char *_data, size_t _len) OP_ARG_NONNULL(2)</td></tr>
<tr class="separator:gac3259b44ac8dfac93c7adf708de96d78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaac9c6e1916fba6e53152b936055d3db0"><td class="memItemLeft" align="right" valign="top">ogg_int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__header__info.html#gaac9c6e1916fba6e53152b936055d3db0">opus_granule_sample</a> (const <a class="el" href="struct_opus_head.html">OpusHead</a> *_head, ogg_int64_t _gp) OP_ARG_NONNULL(1)</td></tr>
<tr class="separator:gaac9c6e1916fba6e53152b936055d3db0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaed7c41a177cc7338ffec1e7ae57c59b1"><td class="memItemLeft" align="right" valign="top">OP_WARN_UNUSED_RESULT int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__header__info.html#gaed7c41a177cc7338ffec1e7ae57c59b1">opus_tags_parse</a> (<a class="el" href="struct_opus_tags.html">OpusTags</a> *_tags, const unsigned char *_data, size_t _len) OP_ARG_NONNULL(2)</td></tr>
<tr class="separator:gaed7c41a177cc7338ffec1e7ae57c59b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaceda528fa8f9f9ad1443df2eeeeaa8bf"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__header__info.html#gaceda528fa8f9f9ad1443df2eeeeaa8bf">opus_tags_copy</a> (<a class="el" href="struct_opus_tags.html">OpusTags</a> *_dst, const <a class="el" href="struct_opus_tags.html">OpusTags</a> *_src) OP_ARG_NONNULL(1)</td></tr>
<tr class="separator:gaceda528fa8f9f9ad1443df2eeeeaa8bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga35f993f5a8f11337a6503a2f43996fea"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_s_d_l__opengles2__gl2ext_8h.html#ae5d8fa23ad07c48bb609509eae494c95">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__header__info.html#ga35f993f5a8f11337a6503a2f43996fea">opus_tags_init</a> (<a class="el" href="struct_opus_tags.html">OpusTags</a> *_tags) OP_ARG_NONNULL(1)</td></tr>
<tr class="separator:ga35f993f5a8f11337a6503a2f43996fea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga42bc0321740b618271c4cd0ae076d29a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__header__info.html#ga42bc0321740b618271c4cd0ae076d29a">opus_tags_add</a> (<a class="el" href="struct_opus_tags.html">OpusTags</a> *_tags, const char *_tag, const char *_value) OP_ARG_NONNULL(1) OP_ARG_NONNULL(2) OP_ARG_NONNULL(3)</td></tr>
<tr class="separator:ga42bc0321740b618271c4cd0ae076d29a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga76ac5425d8c2ca9a994f84adfcc6cb98"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__header__info.html#ga76ac5425d8c2ca9a994f84adfcc6cb98">opus_tags_add_comment</a> (<a class="el" href="struct_opus_tags.html">OpusTags</a> *_tags, const char *_comment) OP_ARG_NONNULL(1) OP_ARG_NONNULL(2)</td></tr>
<tr class="separator:ga76ac5425d8c2ca9a994f84adfcc6cb98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga670be1155863aabc9f8d2cf064021131"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__header__info.html#ga670be1155863aabc9f8d2cf064021131">opus_tags_set_binary_suffix</a> (<a class="el" href="struct_opus_tags.html">OpusTags</a> *_tags, const unsigned char *_data, int _len) OP_ARG_NONNULL(1)</td></tr>
<tr class="separator:ga670be1155863aabc9f8d2cf064021131"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad43a7ed5844debd7d4025335f096bc27"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__header__info.html#gad43a7ed5844debd7d4025335f096bc27">opus_tags_query</a> (const <a class="el" href="struct_opus_tags.html">OpusTags</a> *_tags, const char *_tag, int _count) OP_ARG_NONNULL(1) OP_ARG_NONNULL(2)</td></tr>
<tr class="separator:gad43a7ed5844debd7d4025335f096bc27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6e0bbe5a717115180bf4aa596bd0b2d1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__header__info.html#ga6e0bbe5a717115180bf4aa596bd0b2d1">opus_tags_query_count</a> (const <a class="el" href="struct_opus_tags.html">OpusTags</a> *_tags, const char *_tag) OP_ARG_NONNULL(1) OP_ARG_NONNULL(2)</td></tr>
<tr class="separator:ga6e0bbe5a717115180bf4aa596bd0b2d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac13718002d2ca508ed1c04a40339877d"><td class="memItemLeft" align="right" valign="top">const unsigned char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__header__info.html#gac13718002d2ca508ed1c04a40339877d">opus_tags_get_binary_suffix</a> (const <a class="el" href="struct_opus_tags.html">OpusTags</a> *_tags, int *_len) OP_ARG_NONNULL(1) OP_ARG_NONNULL(2)</td></tr>
<tr class="separator:gac13718002d2ca508ed1c04a40339877d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab830a22ec7341069f3928d505ad04a56"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__header__info.html#gab830a22ec7341069f3928d505ad04a56">opus_tags_get_album_gain</a> (const <a class="el" href="struct_opus_tags.html">OpusTags</a> *_tags, int *_gain_q8) OP_ARG_NONNULL(1) OP_ARG_NONNULL(2)</td></tr>
<tr class="separator:gab830a22ec7341069f3928d505ad04a56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga093ce83b90c68951f2e6aedc66344ce5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__header__info.html#ga093ce83b90c68951f2e6aedc66344ce5">opus_tags_get_track_gain</a> (const <a class="el" href="struct_opus_tags.html">OpusTags</a> *_tags, int *_gain_q8) OP_ARG_NONNULL(1) OP_ARG_NONNULL(2)</td></tr>
<tr class="separator:ga093ce83b90c68951f2e6aedc66344ce5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga16d4f85561a965d56e0c5177fa129c35"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_s_d_l__opengles2__gl2ext_8h.html#ae5d8fa23ad07c48bb609509eae494c95">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__header__info.html#ga16d4f85561a965d56e0c5177fa129c35">opus_tags_clear</a> (<a class="el" href="struct_opus_tags.html">OpusTags</a> *_tags) OP_ARG_NONNULL(1)</td></tr>
<tr class="separator:ga16d4f85561a965d56e0c5177fa129c35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaad7582aee9be320d26b13f77e7b54106"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__header__info.html#gaad7582aee9be320d26b13f77e7b54106">opus_tagcompare</a> (const char *_tag_name, const char *_comment)</td></tr>
<tr class="separator:gaad7582aee9be320d26b13f77e7b54106"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabf02fa65e49fde045ef787e42ef7b8c0"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__header__info.html#gabf02fa65e49fde045ef787e42ef7b8c0">opus_tagncompare</a> (const char *_tag_name, int _tag_len, const char *_comment)</td></tr>
<tr class="separator:gabf02fa65e49fde045ef787e42ef7b8c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6487af1d21fe87f4815567d85a27989a"><td class="memItemLeft" align="right" valign="top">OP_WARN_UNUSED_RESULT int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__header__info.html#ga6487af1d21fe87f4815567d85a27989a">opus_picture_tag_parse</a> (<a class="el" href="struct_opus_picture_tag.html">OpusPictureTag</a> *_pic, const char *_tag) OP_ARG_NONNULL(1) OP_ARG_NONNULL(2)</td></tr>
<tr class="separator:ga6487af1d21fe87f4815567d85a27989a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga09b9724bb7a9abd1d78680bd7d420ec2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_s_d_l__opengles2__gl2ext_8h.html#ae5d8fa23ad07c48bb609509eae494c95">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__header__info.html#ga09b9724bb7a9abd1d78680bd7d420ec2">opus_picture_tag_init</a> (<a class="el" href="struct_opus_picture_tag.html">OpusPictureTag</a> *_pic) OP_ARG_NONNULL(1)</td></tr>
<tr class="separator:ga09b9724bb7a9abd1d78680bd7d420ec2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga26a732722fc74274d76b855020822852"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_s_d_l__opengles2__gl2ext_8h.html#ae5d8fa23ad07c48bb609509eae494c95">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__header__info.html#ga26a732722fc74274d76b855020822852">opus_picture_tag_clear</a> (<a class="el" href="struct_opus_picture_tag.html">OpusPictureTag</a> *_pic) OP_ARG_NONNULL(1)</td></tr>
<tr class="separator:ga26a732722fc74274d76b855020822852"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="gaa7d5e8cb675cb2da840f258b761e7781"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa7d5e8cb675cb2da840f258b761e7781">&#9670;&nbsp;</a></span>OP_PIC_FORMAT_GIF</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OP_PIC_FORMAT_GIF&#160;&#160;&#160;(3)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The image is a GIF. </p>

<p class="definition">Definition at line <a class="el" href="opusfile_8h_source.html#l00326">326</a> of file <a class="el" href="opusfile_8h_source.html">opusfile.h</a>.</p>

</div>
</div>
<a id="gaf75ae037b78a4a048359261439395450"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf75ae037b78a4a048359261439395450">&#9670;&nbsp;</a></span>OP_PIC_FORMAT_JPEG</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OP_PIC_FORMAT_JPEG&#160;&#160;&#160;(1)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The image is a JPEG. </p>

<p class="definition">Definition at line <a class="el" href="opusfile_8h_source.html#l00322">322</a> of file <a class="el" href="opusfile_8h_source.html">opusfile.h</a>.</p>

</div>
</div>
<a id="ga703554b177ae75bd6999bbd30d485d3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga703554b177ae75bd6999bbd30d485d3f">&#9670;&nbsp;</a></span>OP_PIC_FORMAT_PNG</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OP_PIC_FORMAT_PNG&#160;&#160;&#160;(2)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The image is a PNG. </p>

<p class="definition">Definition at line <a class="el" href="opusfile_8h_source.html#l00324">324</a> of file <a class="el" href="opusfile_8h_source.html">opusfile.h</a>.</p>

</div>
</div>
<a id="gade2f09dce6330529fc3c96d1740df653"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gade2f09dce6330529fc3c96d1740df653">&#9670;&nbsp;</a></span>OP_PIC_FORMAT_UNKNOWN</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OP_PIC_FORMAT_UNKNOWN&#160;&#160;&#160;(-1)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The MIME type was not recognized, or the image data did not match the declared MIME type. </p>

<p class="definition">Definition at line <a class="el" href="opusfile_8h_source.html#l00318">318</a> of file <a class="el" href="opusfile_8h_source.html">opusfile.h</a>.</p>

</div>
</div>
<a id="gaac4ef30a33caf090b9b1a5ada8f48204"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaac4ef30a33caf090b9b1a5ada8f48204">&#9670;&nbsp;</a></span>OP_PIC_FORMAT_URL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OP_PIC_FORMAT_URL&#160;&#160;&#160;(0)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The MIME type indicates the image data is really a URL. </p>

<p class="definition">Definition at line <a class="el" href="opusfile_8h_source.html#l00320">320</a> of file <a class="el" href="opusfile_8h_source.html">opusfile.h</a>.</p>

</div>
</div>
<a id="gad6f0329582430a828244045ac85a5417"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad6f0329582430a828244045ac85a5417">&#9670;&nbsp;</a></span>OPUS_CHANNEL_COUNT_MAX</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OPUS_CHANNEL_COUNT_MAX&#160;&#160;&#160;(255)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The maximum number of channels in an Ogg Opus stream. </p>

<p class="definition">Definition at line <a class="el" href="opusfile_8h_source.html#l00210">210</a> of file <a class="el" href="opusfile_8h_source.html">opusfile.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="gaac9c6e1916fba6e53152b936055d3db0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaac9c6e1916fba6e53152b936055d3db0">&#9670;&nbsp;</a></span>opus_granule_sample()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ogg_int64_t opus_granule_sample </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_opus_head.html">OpusHead</a> *&#160;</td>
          <td class="paramname"><em>_head</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ogg_int64_t&#160;</td>
          <td class="paramname"><em>_gp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Converts a granule position to a sample offset for a given Ogg Opus stream. The sample offset is simply <code>_gp-_head-&gt;pre_skip</code>. Granule position values smaller than <a class="el" href="struct_opus_head.html#ab448d3d3289d99f01dca8f19e878d57f">OpusHead::pre_skip</a> correspond to audio that should never be played, and thus have no associated sample offset. This function returns -1 for such values. This function also correctly handles extremely large granule positions, which may have wrapped around to a negative number when stored in a signed ogg_int64_t value. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_head</td><td>The <a class="el" href="struct_opus_head.html">OpusHead</a> information from the ID header of the stream. </td></tr>
    <tr><td class="paramname">_gp</td><td>The granule position to convert. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The sample offset associated with the given granule position (counting at a 48 kHz sampling rate), or the special value -1 on error (i.e., the granule position was smaller than the pre-skip amount). </dd></dl>

</div>
</div>
<a id="gac3259b44ac8dfac93c7adf708de96d78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac3259b44ac8dfac93c7adf708de96d78">&#9670;&nbsp;</a></span>opus_head_parse()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OP_WARN_UNUSED_RESULT int opus_head_parse </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_opus_head.html">OpusHead</a> *&#160;</td>
          <td class="paramname"><em>_head</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned char *&#160;</td>
          <td class="paramname"><em>_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>_len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Parses the contents of the ID header packet of an Ogg Opus stream. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">_head</td><td>Returns the contents of the parsed packet. The contents of this structure are untouched on error. This may be <code>NULL</code> to merely test the header for validity. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">_data</td><td>The contents of the ID header packet. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">_len</td><td>The number of bytes of data in the ID header packet. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success or a negative value on error. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname"><a class="el" href="group__error__codes.html#gafca3ae244d24e10b2851c77379453220">OP_ENOTFORMAT</a></td><td>If the data does not start with the "OpusHead" string. </td></tr>
    <tr><td class="paramname"><a class="el" href="group__error__codes.html#gaa9ae4494f623f3c0609f0b4bd99b8f32">OP_EVERSION</a></td><td>If the version field signaled a version this library does not know how to parse. </td></tr>
    <tr><td class="paramname"><a class="el" href="group__error__codes.html#gaeea27378f826033ca23584d8403665d3">OP_EIMPL</a></td><td>If the channel mapping family was 255, which general purpose players should not attempt to play. </td></tr>
    <tr><td class="paramname"><a class="el" href="group__error__codes.html#ga534f1b45c8733a2928434e482b38869f">OP_EBADHEADER</a></td><td>If the contents of the packet otherwise violate the Ogg Opus specification: <ul>
<li>
Insufficient data, </li>
<li>
Too much data for the known minor versions, </li>
<li>
An unrecognized channel mapping family, </li>
<li>
Zero channels or too many channels, </li>
<li>
Zero coded streams, </li>
<li>
Too many coupled streams, or </li>
<li>
An invalid channel mapping index. </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga26a732722fc74274d76b855020822852"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga26a732722fc74274d76b855020822852">&#9670;&nbsp;</a></span>opus_picture_tag_clear()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_s_d_l__opengles2__gl2ext_8h.html#ae5d8fa23ad07c48bb609509eae494c95">void</a> opus_picture_tag_clear </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_opus_picture_tag.html">OpusPictureTag</a> *&#160;</td>
          <td class="paramname"><em>_pic</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Clears the <a class="el" href="struct_opus_picture_tag.html">OpusPictureTag</a> structure. This should be called on an <a class="el" href="struct_opus_picture_tag.html">OpusPictureTag</a> structure after it is no longer needed. It will free all memory used by the structure members. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_pic</td><td>The <a class="el" href="struct_opus_picture_tag.html">OpusPictureTag</a> structure to clear. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga09b9724bb7a9abd1d78680bd7d420ec2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga09b9724bb7a9abd1d78680bd7d420ec2">&#9670;&nbsp;</a></span>opus_picture_tag_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_s_d_l__opengles2__gl2ext_8h.html#ae5d8fa23ad07c48bb609509eae494c95">void</a> opus_picture_tag_init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_opus_picture_tag.html">OpusPictureTag</a> *&#160;</td>
          <td class="paramname"><em>_pic</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initializes an <a class="el" href="struct_opus_picture_tag.html">OpusPictureTag</a> structure. This should be called on a freshly allocated <a class="el" href="struct_opus_picture_tag.html">OpusPictureTag</a> structure before attempting to use it. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_pic</td><td>The <a class="el" href="struct_opus_picture_tag.html">OpusPictureTag</a> structure to initialize. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga6487af1d21fe87f4815567d85a27989a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6487af1d21fe87f4815567d85a27989a">&#9670;&nbsp;</a></span>opus_picture_tag_parse()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OP_WARN_UNUSED_RESULT int opus_picture_tag_parse </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_opus_picture_tag.html">OpusPictureTag</a> *&#160;</td>
          <td class="paramname"><em>_pic</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>_tag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Parse a single METADATA_BLOCK_PICTURE tag. This decodes the BASE64-encoded content of the tag and returns a structure with the MIME type, description, image parameters (if known), and the compressed image data. If the MIME type indicates the presence of an image format we recognize (JPEG, PNG, or GIF) and the actual image data contains the magic signature associated with that format, then the <a class="el" href="struct_opus_picture_tag.html#aba2d71a09ecf0999cf5faf7c2276fb37">OpusPictureTag::format</a> field will be set to the corresponding format. This is provided as a convenience to avoid requiring applications to parse the MIME type and/or do their own format detection for the commonly used formats. In this case, we also attempt to extract the image parameters directly from the image data (overriding any that were present in the tag, which the specification says applications are not meant to rely on). The application must still provide its own support for actually decoding the image data and, if applicable, retrieving that data from URLs. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">_pic</td><td>Returns the parsed picture data. No sanitation is done on the type, MIME type, or description fields, so these might return invalid values. The contents of this structure are left unmodified on failure. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">_tag</td><td>The METADATA_BLOCK_PICTURE tag contents. The leading "METADATA_BLOCK_PICTURE=" portion is optional, to allow the function to be used on either directly on the values in <a class="el" href="struct_opus_tags.html#ad53d571bd8b23691089242e4e161358a">OpusTags::user_comments</a> or on the return value of <a class="el" href="group__header__info.html#gad43a7ed5844debd7d4025335f096bc27">opus_tags_query()</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success or a negative value on error. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname"><a class="el" href="group__error__codes.html#gafca3ae244d24e10b2851c77379453220">OP_ENOTFORMAT</a></td><td>The METADATA_BLOCK_PICTURE contents were not valid. </td></tr>
    <tr><td class="paramname"><a class="el" href="group__error__codes.html#ga2ddb887c0bb55c74ea6be391fabcba59">OP_EFAULT</a></td><td>There was not enough memory to store the picture tag contents. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaad7582aee9be320d26b13f77e7b54106"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaad7582aee9be320d26b13f77e7b54106">&#9670;&nbsp;</a></span>opus_tagcompare()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int opus_tagcompare </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>_tag_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>_comment</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Check if <em>_comment</em> is an instance of a <em>_tag_name</em> tag. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="group__header__info.html#gabf02fa65e49fde045ef787e42ef7b8c0">opus_tagncompare</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_tag_name</td><td>A NUL-terminated, case-insensitive, ASCII string containing the name of the tag to check for (without the terminating '=' character). </td></tr>
    <tr><td class="paramname">_comment</td><td>The comment string to check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An integer less than, equal to, or greater than zero if <em>_comment</em> is found respectively, to be less than, to match, or be greater than a "tag=value" string whose tag matches <em>_tag_name</em>. </dd></dl>

</div>
</div>
<a id="gabf02fa65e49fde045ef787e42ef7b8c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabf02fa65e49fde045ef787e42ef7b8c0">&#9670;&nbsp;</a></span>opus_tagncompare()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int opus_tagncompare </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>_tag_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>_tag_len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>_comment</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Check if <em>_comment</em> is an instance of a <em>_tag_name</em> tag. This version is slightly more efficient than <a class="el" href="group__header__info.html#gaad7582aee9be320d26b13f77e7b54106">opus_tagcompare()</a> if the length of the tag name is already known (e.g., because it is a constant). </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="group__header__info.html#gaad7582aee9be320d26b13f77e7b54106">opus_tagcompare</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_tag_name</td><td>A case-insensitive ASCII string containing the name of the tag to check for (without the terminating '=' character). </td></tr>
    <tr><td class="paramname">_tag_len</td><td>The number of characters in the tag name. This must be non-negative. </td></tr>
    <tr><td class="paramname">_comment</td><td>The comment string to check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An integer less than, equal to, or greater than zero if <em>_comment</em> is found respectively, to be less than, to match, or be greater than a "tag=value" string whose tag matches the first <em>_tag_len</em> characters of <em>_tag_name</em>. </dd></dl>

</div>
</div>
<a id="ga42bc0321740b618271c4cd0ae076d29a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga42bc0321740b618271c4cd0ae076d29a">&#9670;&nbsp;</a></span>opus_tags_add()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int opus_tags_add </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_opus_tags.html">OpusTags</a> *&#160;</td>
          <td class="paramname"><em>_tags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>_tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Add a (tag, value) pair to an initialized <a class="el" href="struct_opus_tags.html">OpusTags</a> structure. </p><dl class="section note"><dt>Note</dt><dd>Neither <a class="el" href="group__header__info.html#ga42bc0321740b618271c4cd0ae076d29a">opus_tags_add()</a> nor <a class="el" href="group__header__info.html#ga76ac5425d8c2ca9a994f84adfcc6cb98">opus_tags_add_comment()</a> support values containing embedded NULs, although the bitstream format does support them. To add such tags, you will need to manipulate the <a class="el" href="struct_opus_tags.html">OpusTags</a> structure directly. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_tags</td><td>The <a class="el" href="struct_opus_tags.html">OpusTags</a> structure to add the (tag, value) pair to. </td></tr>
    <tr><td class="paramname">_tag</td><td>A NUL-terminated, case-insensitive, ASCII string containing the tag to add (without an '=' character). </td></tr>
    <tr><td class="paramname">_value</td><td>A NUL-terminated UTF-8 containing the corresponding value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, or a negative value on failure. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname"><a class="el" href="group__error__codes.html#ga2ddb887c0bb55c74ea6be391fabcba59">OP_EFAULT</a></td><td>An internal memory allocation failed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga76ac5425d8c2ca9a994f84adfcc6cb98"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga76ac5425d8c2ca9a994f84adfcc6cb98">&#9670;&nbsp;</a></span>opus_tags_add_comment()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int opus_tags_add_comment </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_opus_tags.html">OpusTags</a> *&#160;</td>
          <td class="paramname"><em>_tags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>_comment</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Add a comment to an initialized <a class="el" href="struct_opus_tags.html">OpusTags</a> structure. </p><dl class="section note"><dt>Note</dt><dd>Neither <a class="el" href="group__header__info.html#ga76ac5425d8c2ca9a994f84adfcc6cb98">opus_tags_add_comment()</a> nor <a class="el" href="group__header__info.html#ga42bc0321740b618271c4cd0ae076d29a">opus_tags_add()</a> support comments containing embedded NULs, although the bitstream format does support them. To add such tags, you will need to manipulate the <a class="el" href="struct_opus_tags.html">OpusTags</a> structure directly. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_tags</td><td>The <a class="el" href="struct_opus_tags.html">OpusTags</a> structure to add the comment to. </td></tr>
    <tr><td class="paramname">_comment</td><td>A NUL-terminated UTF-8 string containing the comment in "TAG=value" form. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, or a negative value on failure. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname"><a class="el" href="group__error__codes.html#ga2ddb887c0bb55c74ea6be391fabcba59">OP_EFAULT</a></td><td>An internal memory allocation failed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga16d4f85561a965d56e0c5177fa129c35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga16d4f85561a965d56e0c5177fa129c35">&#9670;&nbsp;</a></span>opus_tags_clear()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_s_d_l__opengles2__gl2ext_8h.html#ae5d8fa23ad07c48bb609509eae494c95">void</a> opus_tags_clear </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_opus_tags.html">OpusTags</a> *&#160;</td>
          <td class="paramname"><em>_tags</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Clears the <a class="el" href="struct_opus_tags.html">OpusTags</a> structure. This should be called on an <a class="el" href="struct_opus_tags.html">OpusTags</a> structure after it is no longer needed. It will free all memory used by the structure members. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_tags</td><td>The <a class="el" href="struct_opus_tags.html">OpusTags</a> structure to clear. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaceda528fa8f9f9ad1443df2eeeeaa8bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaceda528fa8f9f9ad1443df2eeeeaa8bf">&#9670;&nbsp;</a></span>opus_tags_copy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int opus_tags_copy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_opus_tags.html">OpusTags</a> *&#160;</td>
          <td class="paramname"><em>_dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_opus_tags.html">OpusTags</a> *&#160;</td>
          <td class="paramname"><em>_src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Performs a deep copy of an <a class="el" href="struct_opus_tags.html">OpusTags</a> structure. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_dst</td><td>The <a class="el" href="struct_opus_tags.html">OpusTags</a> structure to copy into. If this function fails, the contents of this structure remain untouched. </td></tr>
    <tr><td class="paramname">_src</td><td>The <a class="el" href="struct_opus_tags.html">OpusTags</a> structure to copy from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>Success. </td></tr>
    <tr><td class="paramname"><a class="el" href="group__error__codes.html#ga2ddb887c0bb55c74ea6be391fabcba59">OP_EFAULT</a></td><td>If there wasn't enough memory to copy the tags. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gab830a22ec7341069f3928d505ad04a56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab830a22ec7341069f3928d505ad04a56">&#9670;&nbsp;</a></span>opus_tags_get_album_gain()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int opus_tags_get_album_gain </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_opus_tags.html">OpusTags</a> *&#160;</td>
          <td class="paramname"><em>_tags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>_gain_q8</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the album gain from an R128_ALBUM_GAIN tag, if one was specified. This searches for the first R128_ALBUM_GAIN tag with a valid signed, 16-bit decimal integer value and returns the value. This routine is exposed merely for convenience for applications which wish to do something special with the album gain (i.e., display it). If you simply wish to apply the album gain instead of the header gain, you can use <a class="el" href="group__stream__decoding.html#ga7df927613ccf57996319678e08513289">op_set_gain_offset()</a> with an <a class="el" href="group__stream__decoding.html#ga72d2506ae978f7dbd3a6a59c57f21036">OP_ALBUM_GAIN</a> type and no offset. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">_tags</td><td>An initialized <a class="el" href="struct_opus_tags.html">OpusTags</a> structure. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">_gain_q8</td><td>The album gain, in 1/256ths of a dB. This will lie in the range [-32768,32767], and should be applied in <em>addition</em> to the header gain. On error, no value is returned, and the previous contents remain unchanged. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, or a negative value on error. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname"><a class="el" href="group__error__codes.html#ga4fd28e64a5cbe5e0ba163916199611a5">OP_FALSE</a></td><td>There was no album gain available in the given tags. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gac13718002d2ca508ed1c04a40339877d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac13718002d2ca508ed1c04a40339877d">&#9670;&nbsp;</a></span>opus_tags_get_binary_suffix()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const unsigned char* opus_tags_get_binary_suffix </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_opus_tags.html">OpusTags</a> *&#160;</td>
          <td class="paramname"><em>_tags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>_len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Retrieve the binary suffix data at the end of the packet (if any). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">_tags</td><td>An initialized <a class="el" href="struct_opus_tags.html">OpusTags</a> structure. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">_len</td><td>Returns the number of bytes of binary suffix data returned. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the binary suffix data, or <code>NULL</code> if none was present. </dd></dl>

</div>
</div>
<a id="ga093ce83b90c68951f2e6aedc66344ce5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga093ce83b90c68951f2e6aedc66344ce5">&#9670;&nbsp;</a></span>opus_tags_get_track_gain()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int opus_tags_get_track_gain </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_opus_tags.html">OpusTags</a> *&#160;</td>
          <td class="paramname"><em>_tags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>_gain_q8</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the track gain from an R128_TRACK_GAIN tag, if one was specified. This searches for the first R128_TRACK_GAIN tag with a valid signed, 16-bit decimal integer value and returns the value. This routine is exposed merely for convenience for applications which wish to do something special with the track gain (i.e., display it). If you simply wish to apply the track gain instead of the header gain, you can use <a class="el" href="group__stream__decoding.html#ga7df927613ccf57996319678e08513289">op_set_gain_offset()</a> with an <a class="el" href="group__stream__decoding.html#ga51082f7c661488bce9bfdf0e5401fabf">OP_TRACK_GAIN</a> type and no offset. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">_tags</td><td>An initialized <a class="el" href="struct_opus_tags.html">OpusTags</a> structure. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">_gain_q8</td><td>The track gain, in 1/256ths of a dB. This will lie in the range [-32768,32767], and should be applied in <em>addition</em> to the header gain. On error, no value is returned, and the previous contents remain unchanged. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, or a negative value on error. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname"><a class="el" href="group__error__codes.html#ga4fd28e64a5cbe5e0ba163916199611a5">OP_FALSE</a></td><td>There was no track gain available in the given tags. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga35f993f5a8f11337a6503a2f43996fea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga35f993f5a8f11337a6503a2f43996fea">&#9670;&nbsp;</a></span>opus_tags_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_s_d_l__opengles2__gl2ext_8h.html#ae5d8fa23ad07c48bb609509eae494c95">void</a> opus_tags_init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_opus_tags.html">OpusTags</a> *&#160;</td>
          <td class="paramname"><em>_tags</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initializes an <a class="el" href="struct_opus_tags.html">OpusTags</a> structure. This should be called on a freshly allocated <a class="el" href="struct_opus_tags.html">OpusTags</a> structure before attempting to use it. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_tags</td><td>The <a class="el" href="struct_opus_tags.html">OpusTags</a> structure to initialize. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaed7c41a177cc7338ffec1e7ae57c59b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaed7c41a177cc7338ffec1e7ae57c59b1">&#9670;&nbsp;</a></span>opus_tags_parse()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OP_WARN_UNUSED_RESULT int opus_tags_parse </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_opus_tags.html">OpusTags</a> *&#160;</td>
          <td class="paramname"><em>_tags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned char *&#160;</td>
          <td class="paramname"><em>_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>_len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Parses the contents of the 'comment' header packet of an Ogg Opus stream. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">_tags</td><td>An uninitialized <a class="el" href="struct_opus_tags.html">OpusTags</a> structure. This returns the contents of the parsed packet. The contents of this structure are untouched on error. This may be <code>NULL</code> to merely test the header for validity. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">_data</td><td>The contents of the 'comment' header packet. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">_len</td><td>The number of bytes of data in the 'info' header packet. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>Success. </td></tr>
    <tr><td class="paramname"><a class="el" href="group__error__codes.html#gafca3ae244d24e10b2851c77379453220">OP_ENOTFORMAT</a></td><td>If the data does not start with the "OpusTags" string. </td></tr>
    <tr><td class="paramname"><a class="el" href="group__error__codes.html#ga534f1b45c8733a2928434e482b38869f">OP_EBADHEADER</a></td><td>If the contents of the packet otherwise violate the Ogg Opus specification. </td></tr>
    <tr><td class="paramname"><a class="el" href="group__error__codes.html#ga2ddb887c0bb55c74ea6be391fabcba59">OP_EFAULT</a></td><td>If there wasn't enough memory to store the tags. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gad43a7ed5844debd7d4025335f096bc27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad43a7ed5844debd7d4025335f096bc27">&#9670;&nbsp;</a></span>opus_tags_query()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* opus_tags_query </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_opus_tags.html">OpusTags</a> *&#160;</td>
          <td class="paramname"><em>_tags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>_tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>_count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Look up a comment value by its tag. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_tags</td><td>An initialized <a class="el" href="struct_opus_tags.html">OpusTags</a> structure. </td></tr>
    <tr><td class="paramname">_tag</td><td>The tag to look up. </td></tr>
    <tr><td class="paramname">_count</td><td>The instance of the tag. The same tag can appear multiple times, each with a distinct value, so an index is required to retrieve them all. The order in which these values appear is significant and should be preserved. Use <a class="el" href="group__header__info.html#ga6e0bbe5a717115180bf4aa596bd0b2d1">opus_tags_query_count()</a> to get the legal range for the <em>_count</em> parameter. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the queried tag's value. This points directly to data in the <a class="el" href="struct_opus_tags.html">OpusTags</a> structure. It should not be modified or freed by the application, and modifications to the structure may invalidate the pointer. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">NULL</td><td>If no matching tag is found. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga6e0bbe5a717115180bf4aa596bd0b2d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6e0bbe5a717115180bf4aa596bd0b2d1">&#9670;&nbsp;</a></span>opus_tags_query_count()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int opus_tags_query_count </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_opus_tags.html">OpusTags</a> *&#160;</td>
          <td class="paramname"><em>_tags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>_tag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Look up the number of instances of a tag. Call this first when querying for a specific tag and then iterate over the number of instances with separate calls to <a class="el" href="group__header__info.html#gad43a7ed5844debd7d4025335f096bc27">opus_tags_query()</a> to retrieve all the values for that tag in order. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_tags</td><td>An initialized <a class="el" href="struct_opus_tags.html">OpusTags</a> structure. </td></tr>
    <tr><td class="paramname">_tag</td><td>The tag to look up. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of instances of this particular tag. </dd></dl>

</div>
</div>
<a id="ga670be1155863aabc9f8d2cf064021131"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga670be1155863aabc9f8d2cf064021131">&#9670;&nbsp;</a></span>opus_tags_set_binary_suffix()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int opus_tags_set_binary_suffix </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_opus_tags.html">OpusTags</a> *&#160;</td>
          <td class="paramname"><em>_tags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned char *&#160;</td>
          <td class="paramname"><em>_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>_len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Replace the binary suffix data at the end of the packet (if any). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_tags</td><td>An initialized <a class="el" href="struct_opus_tags.html">OpusTags</a> structure. </td></tr>
    <tr><td class="paramname">_data</td><td>A buffer of binary data to append after the encoded user comments. The least significant bit of the first byte of this data must be set (to ensure the data is preserved by other editors). </td></tr>
    <tr><td class="paramname">_len</td><td>The number of bytes of binary data to append. This may be zero to remove any existing binary suffix data. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, or a negative value on error. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname"><a class="el" href="group__error__codes.html#gae0879acafe9cc0ab72462d291fdb6fb6">OP_EINVAL</a></td><td><em>_len</em> was negative, or <em>_len</em> was positive but <em>_data</em> was <code>NULL</code> or the least significant bit of the first byte was not set. </td></tr>
    <tr><td class="paramname"><a class="el" href="group__error__codes.html#ga2ddb887c0bb55c74ea6be391fabcba59">OP_EFAULT</a></td><td>An internal memory allocation failed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.15
</small></address>
</body>
</html>
